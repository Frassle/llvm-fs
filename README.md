# llvm-fs: An F# binding for LLVM

Note that this binding is pretty early in development and so far has only been
tested with mono on OS X. Most of the binding code is generated by bindinggen
as a part of the build process so that code is not checked into the repository
but you can see all of the LLVM interface types (including generated types)
[here](https://github.com/keithshep/llvm-fs/wiki/LLVM-F%23-Interface).

## Building

1. Build and install LLVM as a shared library.
   Eg: `./configure --enable-shared --enable-jit && make && make install`

2. Build the LLVM binding DLL. You can use the build.bash file as a starting
   point. It's likely that the only thing you will have to change are the
   parameters which are passed to bindinggen.exe:
   `bindinggen.exe DLL_NAME LLVM_INSTALL_DIR BINDING_SRC_DIR`. There is probably
   no reason to change the BINDING_SRC_DIR

3. Build your application in the same way that the tests are built.
   Eg: `fsc -r LLVMFSharp.dll test/simpletest.fs`

## Contribution Ideas

It would be great to get some code contributions from others. If you're
motivated here are some ideas:

- Tests and examples: most of the binding code was autogenerated and the test
  coverage is very low. I'm happy to have any test cases or examples that you can
  contribute.

- A cross-patform build to replace my `build.bash` and `clean.bash` files

- A more high-level interface. The [haskell LLVM](http://hackage.haskell.org/package/llvm)
  binding has built some nice abstractions on top of monads. I'm not sure how
  well this would translate to
  [F# Computation Expressions](http://msdn.microsoft.com/en-us/library/dd233182.aspx)
  but it seems worth looking into. It might be just as well to define a module
  with some higher level functions and classes instead.

- More "F# friendly" LLVM functions. The binding generator will normally generate
  two functions per function definition in the LLVM headers which are scanned.
  First there is the "native" function which takes a tuple argument and
  not-so-safe argument types. The other is an F# friendly definition with
  curried arguments and stronger types. For some of the functions the generator
  isn't smart enough to infer the F# friendly type and these need to be hand
  coded. You can find all of them by running this grep:
  `find src/LLVM/Generated -name '*.fs' | xargs grep "F# friendly"`. Which
  will find a bunch of generated comments for the missing F# friendly
  definitions.

